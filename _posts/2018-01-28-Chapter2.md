---
layout: post
title: "Chapter 2: Encryption"
date: 2018-01-28 13:06:04
categories: blog appliedcryptography
last_update: 2018-02-16
summary: Solutions and beyond on Exercises in <u>Chapter 2</u> in <a href="https://crypto.stanford.edu/~dabo/cryptobook/BonehShoup_0_4.pdf" target="_blank"><cite>A Graduate Course in Applied Cryptography</cite></a> text book.
---
[__TL;DR__]()

 This post contains solutions to Exercises in Chapter 2{% sidenote 1 "A Graduate Course in Applied Cryptography [Boneh,D.,Shoup,V.]" %}, which primarily discuss basic concept/building blocks for cryptography study(e.g. Shannon cipher, Definition of Semantic Security, Attack game etc.). On top of that, we dive deeper on further implications and real-life applications motivated by these questions.

* ToC
{:toc}

## 2.1 (multiplicative one-time pad)
### *Question*: 
{% maincolumn "assets/img/Q2.1.png" %}

### _Solution_:

To prove *correctness*, it's trivial to notice: {% m %} D(k,\; E(k,m)) = k^{-1}\cdot k \cdot m\; mod\; p = m \; mod \; p{% em %}.

To prove *perfect secrecy*, we need to use [Theorem 2.1](#theorem-21), intuitively, what we want to prove is: for a uniformly distributed and randomly selected {%m%}k \in \mathcal K{%em%}, and the probability across all possible ciphertext output is uniform.{% sidenote 2 'The "encryption" is a fair dad, giving each kid the same chance to show up, never playing favorites.' %} More formally, we try to show: For {% m %}k \xleftarrow[]{\text{R}} \mathcal K,\;  m_{0},m_{1}\in\mathcal M,\; c\in\mathcal C{% em %} 
{% math %}
\begin{equation}
	\label{eq:1}
		Pr[\,E(k, m_{0})=c\,]\:=\:Pr[\,E(k,m_{1})=c\,]
\end{equation}
{% endmath %}
Equation \eqref{eq:1} is equivalent to the following statement: 
{% math %}
\begin{equation}
	\label{eq:2}
		\textrm{For any fixed }c,\,m \in GF(p), \textrm{there is a unique key }k\in\{0,1,...,p-1\} \textrm{, s.t. }\\
		 k\cdot m =c\; mod \; p.
\end{equation}
{% endmath %}
Or namely, {%m%}k:=m^{-1}\cdot c\; mod \;p{%em%}.

Since the inverse of an element in a prime field is unique (if any){%sidenote 3 'See more math detail in <i>A Computational Introduction to Number Theory and Algebra</i> [Shoup,V.] -- Chapter 2.2 Solving linear congruence '%}, statement \eqref{eq:2} is true, thus complete the proof.

## 2.2 (A good substitution cipher)
### *Question*: 
{% maincolumn "assets/img/Q2.2.png" %}

### *Solution*:

The approach is similar to [Question 2.1](#21-multiplicative-one-time-pad): for {%m%}\mathcal M = \mathcal C = \sum^{L}{%em%} to achieve perfect secrecy, 
{%math%}
\{\begin{array}{l}
c[i] \textrm{ must be independent of } c[j] \textrm{ for all } i\neq j \\
\textrm{for all }e\in\sum,\; i \in \{0,1,...,L-1\} \; Pr[\,e\,] \textrm{ is the same}
\end{array}
{%endmath%}

Since {% m %}k[i] \xleftarrow[]{\text{R}} S,\;{% em %} is randomly selected and uniformly distributed, thus:
{%math%}
\textrm{For any }e \in\sum, \; Pr[\,k[i](m[i])=e\,] = {1\over|\sum|}
{%endmath%}

And according to [Theorem 2.1](#theorem-21), {%m%}\mathcal E{%em%} is perfectly secure.
## 2.3 (Chain encryption)
### *Question*: 
{% maincolumn "assets/img/Q2.3.png" %}

### *Solution*:

The proof is almost identical to [Solution 2.2](#solution-1), the only worthy note is that: in this proof, we need to point out {%m%}k_{1},\, k_{2},\, m{%em%} are independent of each other.

### *Application: access control on encrypted files*:

One might wonder why and where would anybody ever use this "chained encryption" construction, or more straightforward speaking, why not simply encrypting the message with one key instead? As it turns out, such paradigm can be seen in file access control systems. 

In many cases, the {%m%}k_{2}{%em%} in our construction is called a **master key**, while {%m%}k_{1}{%em%} is called an **ephemeral key**. Indicated by their names, *ephemeral key* is for "temporary" use and can be changed from time to time, whereas *master key* means to stay consistent and intact for longer period.

One always uses the master key to encrypt the file, and the *access control* feature is handled by further encrypting the master key using separate, possibly multiple ephemeral keys, each known to one particular user and distributing the encrypted master keys to users. Those ephemeral keys are most likely directly derived from a password through a KDF.{%sidenote 4 'Key Derivation Function: mentioned in Chapter 8, think of this as a deterministic "twisting machine" operating on a somewhat predictable  passphrase of variable length and transform it into a bit string of fixed lenghth with higher entropy.'%} Now this approach has mostly three advantages:

1. User could frequently change their passwords without decrypting and re-encrypting all files on disk. All we need is re-encrypt the master key using this new *ephemeral key* deduced from the new password.
2. *Master key* usually will be randomly generated with a good source of entropy pool, resulting in a bit string that's computationally indistinguishable from random, better than a passphrase which is more vulnerable to dictionary attacks. Plus the encrypted files could be computed once and locked up in a physically secure location.
3. Easier distribution of the decryption key. More than one user could be granted access to the data and even if one forgets his/her password, the encrypted files don't end up Gibberish forever.

For interested readers, you could find a fascinating use case here: [Using Trusted Hardware to build a Password Manager](https://software.intel.com/en-us/articles/intel-software-guard-extensions-tutorial-part-2-app-design). In the fourth post of the series, you could find the architecture inside [Intel SGX](https://software.intel.com/en-us/articles/intel-software-guard-extensions-tutorial-part-1-foundation) using a chained encryption.
## 2.4 (A broken one-time pad)
### *Question*: 
{% maincolumn "assets/img/Q2.4.png" %}
### *Solution*:

An efficient adversary sends two messages of the same length:
{%math%}
m_{0}=0^{L}\\
m_{1}=0^{L-1}\,||\,1
{%endmath%} 

To see why this would completely destroy the one-time pad with advantage of 1, when {%m%}b=0{%em%} or Exp(0), we could expect the number of 1 for the output is even. Compared to when {%m%}b=1{%em%} or Exp(1), there are two cases:
{%math%}
\{\begin{array}{lclcl}
k[L-1]=0 & \rightarrow & \textrm{number of 1 in the first L-1 bit of the output is even} & \rightarrow & \textrm{number of 1 in the final output is odd} \\
k[L-1]=1 & \rightarrow & \textrm{number of 1 in the first L-1 bit of the output is odd} & \rightarrow & \textrm{number of 1 in the final output is odd}
\end{array}
{%endmath%}
As we could see, in both cases, the output turns to have odd number of 1 which enables the adversary to distinguish the two game with probability of 1.

## 2.5 (impossibility result)
### *Question*: 
{% maincolumn "assets/img/Q2.5.png" %}

### *Solution*:

From [Shannon Theorem](#theorem-25), we know that if {%m%}|\mathcal K| \leq |\mathcal M|{%em%}, then there exists {%m%}m_{0}, m_{1}\in \mathcal M, c\in\mathcal C{%em%}, s.t. :
{%math%}
\begin{equation}
	\label{eq:3}
		Pr[E(k,\, m_{0})=c]>0 \;\textrm{and}\; Pr[E(k,\,m_{1})=c]=0
\end{equation}
{%endmath%}

Let {%m%}Z:={%em%} event that \eqref{eq:3} happens, assuming {%m%}|\mathcal M| = (1+\alpha)\cdot|\mathcal K|{%em%}:
{%math%}
\begin{array}{cl}
\rightarrow & Pr[Z]\leq {1\over1+\alpha}\cdot{\alpha\over 1+\alpha}\leq{\alpha\over 1+\alpha}\\
\because & \textrm{SSadv}[\mathcal A, \mathcal E]\leq Pr[Z]\leq\epsilon \\
\rightarrow & {\alpha\over1+\alpha}\leq\epsilon \\
\textrm{or}\; & {1\over1+\alpha}={|\mathcal K|\over|\mathcal M|}\geq 1-\epsilon
\end{array}
{%endmath%}

Thereby finish the proof.
## Shame-free Cheat Sheet
### *Theorem 2.1*:
{% maincolumn 'assets/img/Theorem2_1.png' %}

### *Theorem 2.5*:
{% maincolumn 'assets/img/Theorem2_5.png' %}